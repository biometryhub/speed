---
title: "Common Agricultural Experimental Designs with speed"
author: "Sam Rogers"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: flatly
    highlight: tango
vignette: >
  %\VignetteIndexEntry{Common Agricultural Experimental Designs with speed}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

# Introduction

Agricultural experiments require careful spatial design to minimise the effects of field heterogeneity and neighbour interactions while maximising statistical power. The `speed` package provides tools for creating spatially efficient experimental designs through simulated annealing optimisation.

This vignette demonstrates how to use `speed` for common agricultural experimental designs, showing how spatial optimisation can improve the efficiency and validity of field trials. We'll work through four key design types, each building in complexity and showing different features of the package.

```{r load-package}
library(speed)
```

# Completely Randomised Design (CRD)

## Overview

The Completely Randomised Design is the simplest experimental design where treatments are assigned to experimental units entirely at random. While simple to implement, CRD doesn't account for spatial variation in field conditions.

## When to Use

- Homogeneous experimental conditions
- Controlled environments (greenhouse, growth chamber)
- Small-scale experiments with minimal spatial variation
- Proof-of-concept studies

## Example: Field Trial with 8 Varieties

Consider a field trial testing 8 new wheat varieties with 4 replicates each. Even though treatments are assigned randomly, spatial optimization can reduce neighbor effects and improve precision.

## Setting Up CRD with speed

In agricultural contexts, even completely randomised designs benefit from spatial optimisation to minimise treatment clustering and neighbour effects. Firstly we will initialise a dataframe representing the design and visualise it. This design has 4 replicates of 8 treatments or `items`, with 8 rows and 4 columns.

```{r crd-df}
# Initialise dataframe
crd_design <- initialise_design_df(items = 8, nrows = 8, ncols = 4)
head(crd_design)
```

```{r crd-plot1}
#| echo: false
class(crd_design) <- c("design", class(crd_design))
autoplot(crd_design)
```

This is a systematic layout; note how the initial layout arranges treatments in a repeating, non-random pattern. This will now be randomised before visualisation. 

### Performing the Optimisation

The main `speed()` function performs the optimisation. It has been set up with sensible defaults to allow application to a wide variety of situations. In this case, we only need to provide the design dataframe for it to operate on, the column name of the dataframe to use for the treatments, and a seed for reproducibility. 

```{r crd-example}
crd_result <- speed(crd_design, 
                    swap = "treatment",
                    seed = 42)

crd_result
```

### Output of the Optimisation

The printed output from the returned design object shows the final optimisation score (lower is better), the number of iterations taken to reach that result, if the iterations stopped early due to lack of improvement, the treatments present in the design, and the seed. The output object contains some additional components, which can be seen below:

```{r crd-output}
str(crd_result)
```

### Visualise the Output

The final step is to visualise the optimised design. The plot below displays the spatial arrangement of treatments after optimisation, allowing you to easily check for clustering, spatial trends, or other patterns that may affect your experiment. A well-randomised and spatially efficient design will show treatments distributed evenly across the field, helping to minimise neighbour effects and maximise the reliability of your results.

```{r crd-plot2}
autoplot(crd_result)
```

A nicely randomised and spatially optimal design!


# Randomised Complete Block Design (RCBD)

## Overview

RCBD is one of the most commonly used designs in agricultural research. It controls for one source of variation by grouping experimental units into homogeneous blocks, with each treatment appearing once per block.

## When to Use

- Field experiments with known gradient (slope, soil type, irrigation)
- Medium to large experiments (3+ treatments)
- When blocking factor explains significant variation
- Multi-location trials

## Example: Variety Trial Across Field Gradient

Consider testing 6 soybean varieties across a field with a moisture gradient. Using 4 blocks perpendicular to the gradient helps control for soil moisture variation.

## Setting Up RCBD with speed

Here we initialise a dataframe for a design with 4 blocks and 6 treatments, arranged in 4 rows and 6 columns. Note that we can specify treatments in the `items` argument.

```{r rcbd-df}
rcbd_design <- initialise_design_df(items = paste0("V", 1:6), nrows = 4, ncols = 6, block_nrows = 1, block_ncols = 6)
head(rcbd_design)
```

```{r rcbd-plot1}
#| echo: false

rcbd_design <- rcbd_design[order(rcbd_design$block, rcbd_design$col, rcbd_design$row),]
rcbd_design$treatment <- sort(unique(rcbd_design$treatment))
class(rcbd_design) <- c("design", class(rcbd_design))
autoplot(rcbd_design)
```

This is a systematic block layout; each block contains all treatments in a repeating pattern. This will now be randomised within blocks.

### Performing the Optimisation

```{r rcbd-example}
rcbd_result <- speed(rcbd_design, 
                     swap = "treatment",
                     swap_within = "block",
                     seed = 42)

rcbd_result
```

### Output of the Optimisation

```{r rcbd-output}
str(rcbd_result)
```

### Visualise the Output

```{r rcbd-plot2}
autoplot(rcbd_result)
```

A well-randomised and spatially efficient RCBD layout.

# Latin Square Design

## Overview

Latin Square Design controls for two sources of variation simultaneously by arranging treatments in a square grid where each treatment appears exactly once in each row and column.

## When to Use

- Small to medium experiments (3-10 treatments)
- Two known sources of variation (e.g., row and column effects)
- Greenhouse bench experiments
- Field experiments with two-way gradients

## Constraints

- Number of treatments must equal number of rows and columns
- Limited degrees of freedom for error
- Assumes no row × column interaction

## Setting Up Latin Square with speed

Here we initialise a 5 × 5 Latin square with 5 treatments.

```{r latin-square-df}
latin_square_design <- initialise_design_df(items = 5, nrows = 5, ncols = 5)
head(latin_square_design)
```

```{r latin-square-plot1}
#| echo: false
class(latin_square_design) <- c("design", class(latin_square_design))
autoplot(latin_square_design)
```

This is a systematic Latin square layout; each treatment appears once per row and column. The design will now be randomised.

### Performing the Optimisation

Because of the spatial optimisation algorithm built into `speed`, with default options and enough iterations, it should arrive at a Latin square design in cases where the number of rows, columns, treatments and replicates are all equal such as this.

```{r latin-square-example}
latin_square_result <- speed(latin_square_design, 
                             swap = "treatment",
                             seed = 42)

latin_square_result
```

### Output of the Optimisation

Note that the final score of zero shows that the algorithm has found a perfect Latin Square solution.

```{r latin-square-output}
str(latin_square_result)
```

### Visualise the Output

```{r latin-square-plot2}
autoplot(latin_square_result)
```

A well-randomised and spatially efficient Latin square layout.

# Split-Plot Design

## Overview

Split-Plot Design is used when some treatments are easier to apply to large areas (whole plots) while others require smaller areas (sub-plots). This creates a hierarchical structure with different levels of precision. Split-Plot Designs are particularly useful in agricultural experiments where some factors are difficult or expensive to replicate at the whole plot level. These designs are possible with the `speed` package, allowing for spatial optimisation of both whole plots and sub-plots in a single step.

## When to Use

- Treatments with different application scales (large vs small plots)
- Irrigation × variety experiments
- Tillage × fertilizer studies
- When some treatments are expensive or difficult to replicate

## Structure

- **Whole plots**: Larger experimental units (main treatments)
- **Sub-plots**: Smaller units within whole plots (sub-treatments)
- Different error terms for different treatment levels

## Setting Up Split Plot Design with speed

Now we can create a dataframe representing a split plot design. Note that the `initalise_design_df` function does not currently support split plot designs directly, so we will create it manually.

```{r split-plot-df}
split_plot_design <- data.frame(
    row = rep(1:12, each = 4),
    col = rep(1:4, times = 12),
    block = rep(1:4, each = 12),
    wholeplot = rep(1:12, each = 4),
    wholeplot_treatment = rep(rep(LETTERS[1:3], each = 4), times = 4),
    subplot_treatment = rep(letters[1:4], 12)
 )
head(split_plot_design)
```

```{r split-plot-plot1}
#| echo: false
class(split_plot_design) <- c("design", class(split_plot_design))
autoplot(split_plot_design, treatments = "wholeplot_treatment")
autoplot(split_plot_design, treatments = "subplot_treatment", block = "wholeplot")
```

This is a systematic split plot layout; each treatment appears once per block for wholeplot treatments, and once per whole plot for sub-plot treatments. The design will now be randomised.

### Performing the Optimisation

For split-plot designs, we use named lists to specify the hierarchical structure. The `swap` parameter defines what to optimize at each level, while `swap_within` defines the constraints for each level.

```{r split-plot-example}
split_plot_result <- speed(split_plot_design,
                           swap = list(wp = "wholeplot_treatment",
                                       sp = "subplot_treatment"),
                           swap_within = list(wp = "block", sp = "wholeplot"),
                           seed = 42)

split_plot_result
```

### Output of the Optimisation

The output shows optimization results for the design. The score and iterations are combined for the entire design, while the treatments, and stopping criteria are reported separately for each level, allowing you to assess the quality of optimization at each hierarchy level.

```{r split-plot-output}
str(split_plot_result)
```

### Visualise the Output

```{r split-plot-plot2}
autoplot(split_plot_result, treatments = "wholeplot_treatment")
autoplot(split_plot_result, treatments = "subplot_treatment", block = "wholeplot")
```

This design has now been optimised at both the whole plot level and the sub-plot level.

# Spatial Design Considerations

## Field Shape and Orientation

The shape and orientation of your experimental field significantly impacts design efficiency:

- **Long, narrow fields**: Favor designs with blocks perpendicular to the long axis
- **Square fields**: Allow more flexibility in blocking direction
- **Irregular shapes**: May require custom design approaches

## Neighbour Effects

Agricultural experiments often experience neighbour effects where adjacent plots influence each other:

- **Competition effects**: Tall varieties shading short ones
- **Contamination**: Fertiliser or pesticide drift
- **Root competition**: Nutrient or water competition between plots

The `speed` package specifically addresses these issues through spatial optimisation.

## Buffer Areas

Consider including buffer areas or border plots to:

- Reduce edge effects
- minimise contamination between treatments
- Provide realistic growing conditions

# Using `speed` Effectively

1. **Set appropriate parameters**: Balance optimisation time with improvement
2. **Visualise designs**: Always plot layouts before implementation
3. **Compare alternatives**: Test multiple blocking strategies
4. **Validate results**: Check constraint satisfaction and efficiency metrics

# Conclusion

The `speed` package provides powerful tools for creating spatially efficient experimental designs. By optimising treatment arrangements, researchers can:

- Reduce neighbour effects and spatial confounding
- Improve statistical power and precision
- Maintain design validity and balance
- Visualise and evaluate design quality

Whether using simple randomised designs or complex split-plot structures, spatial optimisation through `speed` can significantly enhance the efficiency and reliability of agricultural experiments.

## Further Reading

- Montgomery, D.C. (2017). *Design and Analysis of Experiments*
- Mead, R. (1988). *The Design of Experiments*
- John, J.A. & Williams, E.R. (1995). *Cyclic and Computer Generated Designs*
- Bailey, R.A. (2008). *Design of Comparative Experiments*

---

*This vignette demonstrates the versatility of the `speed` package for agricultural experimental design. For more advanced applications and custom designs, consult the package documentation and additional vignettes.*
