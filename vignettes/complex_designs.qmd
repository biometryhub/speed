---
title: "Complex Agricultural Experimental Designs with speed"
author: "Sam Rogers"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: flatly
    highlight: tango
vignette: >
  %\VignetteIndexEntry{Complex Agricultural Experimental Designs with speed}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

# Introduction

This vignette covers advanced and complex experimental designs that are used in specialised agricultural research contexts. These designs are particularly useful for plant breeding programs, large-scale variety trials, and situations where standard complete block designs are impractical due to resource constraints or the nature of the treatments.

Building on the foundational designs covered in the [Common Agricultural Experimental Designs vignette](/speed.html), these complex designs offer solutions for challenging experimental scenarios while maintaining statistical rigour through spatial optimisation with the `speed` package.

```{r load-package}
library(speed)
library(patchwork) # For combining plots
```

# Split-Split Plot Designs

## Overview

Split-split plot designs extend the hierarchical structure of [split-plot designs](/speed.html#split-plot-design) to accommodate three factors with different levels of experimental difficulty or practical constraints. This creates a three-level hierarchy of experimental units.

## Hierarchical Structure

### Whole Plots (Main Plots)

- **Largest experimental units**
- **Factor A** applied to whole plots
- **Most difficult factor to randomise**
- **Example**: Tillage systems, irrigation methods

### Sub-Plots (Split Plots)

- **Intermediate-sized units within whole plots**
- **Factor B** applied to sub-plots
- **Moderate randomisation difficulty**
- **Example**: Fertilizer treatments, planting dates

### Sub-Sub-Plots (Split-Split Plots)

- **Smallest experimental units**
- **Factor C** applied to sub-sub-plots
- **Easiest factor to randomise**
- **Example**: Varieties, pesticide treatments

## Error Structure

Complex error structure with multiple error terms:

- **Whole plot error** for Factor A effects
- **Sub-plot error** for Factor B and A×B effects  
- **Sub-sub-plot error** for Factor C and higher-order interactions

## When to Use Split-Split Plot Designs

- **Three factors with different application constraints**
- **Hierarchical treatment structure** matches practical needs
- **Sequential application** of treatments over time
- **Resource or equipment limitations** for some factors

## Examples of Applications

### Agricultural Examples

- **Tillage × Fertilizer × Variety** experiments
- **Irrigation × Planting Date × Cultivar** studies
- **Cover Crop × Nitrogen × Hybrid** trials

### Industrial Examples

- **Temperature × Pressure × Catalyst** process studies
- **Machine × Operator × Material** quality experiments

## Example: Split-Split Plot Design for Agricultural Systems Research

Consider a complex agricultural trial examining Tillage System × Nitrogen Rate × Variety interactions with three hierarchical levels.

## Setting Up Split-Split Plot Designs with speed

```{r split-split-design-df}
split_split_df <- data.frame(
  row = rep(1:16, each = 9),
  col = rep(1:9, times = 16),
  block = rep(1:4, each = 36),
  # Fixed wholeplot assignment: 3 wholeplots per block, each 4×3
  wholeplot = rep(rep(1:3, each = 3), times = 16) + rep(0:3 * 3, each = 36),
  wholeplot_treatment = rep(rep(LETTERS[1:3], each = 3), times = 16),
  subplot = rep(1:48, each = 3),
  subplot_treatment = rep(rep(letters[1:4], each = 9), times = 4),
  subsubplot_treatment = rep(c("x", "y", "z"), 48)
)
```

```{r}
#| echo: false
#| label: fig-ssplot1
#| fig-cap: "Initial layout of the split-split-plot design showing systematic treatment distribution."
class(split_split_df) <- c("design", class(split_split_df))
p1 <- autoplot(split_split_df, treatments = "block") + ggplot2::labs(title = "Blocks")
p2 <- autoplot(split_split_df, treatments = "wholeplot_treatment") + ggplot2::labs(title = "Whole plot Treatments")
p3 <- autoplot(split_split_df, treatments = "subplot_treatment", block = "wholeplot") + ggplot2::labs(title = "Sub-plot Treatments")
p4 <- autoplot(split_split_df, treatments = "subsubplot_treatment", block = "subplot") + ggplot2::labs(title = "Sub-sub-plot Treatments")
p1 + p2 + p3 + p4 +
  plot_layout(ncol = 2) +
  plot_annotation(title = "Initial Split-Split Plot Design")
```

This shows the initial split-split plot design with three-level hierarchical structure.

### Performing the Optimisation

```{r split-split-design-example}
result_ss <- speed(split_split_df,
                   swap = list(wp = "wholeplot_treatment",
                               sp = "subplot_treatment",
                               ssp = "subsubplot_treatment"),
                   swap_within = list(wp = "block",
                                      sp = "wholeplot",
                                      ssp = "subplot"),
                   iterations = list(wp = 2000, 
                                     sp = 5000, 
                                     ssp = 20000),
                   early_stop_iterations = list(wp = 1000, 
                                                sp = 3000, 
                                                ssp = 5000),
                   seed = 42)
```

### Output of the Optimisation

```{r split-split-design-output}
result_ss
```

### Visualise the Output

```{r}
#| label: fig-ssplot2
#| fig-cap: "Final layout of the split-split-plot design showing optimised treatment distribution."
res1 <- autoplot(result_ss, treatments = "wholeplot_treatment") + ggplot2::labs(title = "Whole plot Treatments")
res2 <- autoplot(result_ss, treatments = "subplot_treatment") + ggplot2::labs(title = "Sub-plot Treatments")
res3 <- autoplot(result_ss, treatments = "subsubplot_treatment") + ggplot2::labs(title = "Sub-sub-plot Treatments")
res1 + res2 + res3 +
  plot_layout(ncol = 2) +
  plot_annotation(title = "Optimised Split-Split Plot Design")
```

Above is the final output of this design. Note that there are some adjacent pairs of treatments in the sub-sub-plots. This is quite difficult to avoid in these situations, however adjusting some of the optimisation parameters may help with this. For further information, see the vignette about [changing optimisation parameters for speed](/custom_objective_functions.html).

# Strip-Plot Designs

## Overview

Strip-plot designs are extensions of split-plot designs used when both treatment factors are difficult to apply to small areas. Treatments are arranged in strips that cross each other, creating a grid pattern where intersections represent treatment combinations.

## Structure

- **Horizontal strips** for one factor (e.g., tillage methods)
- **Vertical strips** for another factor (e.g., planting dates)
- **Intersections** represent factor combinations
- **Whole plots** larger than traditional split-plot designs

## When to Use Strip-Plot Designs

- **Both factors require large application areas**
- **Machinery constraints** for both factors
- **Irrigation × cultivation** experiments
- **Planting date × row spacing** studies
- **When split-plot hierarchy doesn't fit** the practical situation

## Advantages and Limitations

### Advantages

- **Accommodates two "difficult-to-randomise" factors**
- **More flexible** than split-plot for certain applications
- **Maintains reasonable precision** for main effects
- **Practical for mechanised agriculture**

### Limitations

- **Lower precision** for interaction effects
- **Complex analysis** with multiple error terms
- **Less efficient** than RCBD for most comparisons
- **Requires larger field areas**

## Example: Strip-Plot Design for Tillage × Planting Date

Consider an experiment testing 3 tillage methods and 4 planting dates where both factors require large application areas.

## Setting Up Strip-Plot Designs with speed

```{r strip-plot-df}
df_strip <- data.frame(
  row = rep(1:12, each = 6),  # 12 rows total (4 rows per block x 6 blocks)
  col = rep(1:6, times = 12),  # 6 columns
  block = rep(rep(1:2, each = 3), times = 4) + rep(0:2*2, each = 24),  # 6 blocks, 12 plots each
  
  # Horizontal strips (3 levels, applied to rows within each block)
  vertical_treatment = rep(rep(LETTERS[1:3], times = 2), times = 12),  # A, B, C
  
  # Vertical strips (4 levels, applied to columns within each block)  
  horizontal_treatment = rep(rep(letters[1:4], each = 6), times = 3),  # a, b, c, d
  
  # Plot identifier within each block
  plot_in_block = rep(1:12, times = 6)
)
```

```{r}
#| echo: false
#| label: fig-strip-plot1
#| fig-cap: "Initial layout of the strip plot design showing systematic treatment distribution."
class(df_strip) <- c("design", class(df_strip))
p1 <- autoplot(df_strip, treatments = "block") + ggplot2::labs(title = "Blocks")
p2 <- autoplot(df_strip, treatments = "horizontal_treatment") + ggplot2::labs(title = "Tillage Treatments")
p3 <- autoplot(df_strip, treatments = "vertical_treatment") + ggplot2::labs(title = "Planting Date Treatments")
p1 + p2 + p3 +
  plot_layout(ncol = 2) +
  plot_annotation(title = "Initial Strip Plot Design")
```

This shows the initial strip-plot layout with horizontal and vertical strips before optimisation.

### Performing the Optimisation

```{r strip-plot-example}
strip_result <- speed(df_strip,
                      swap = list(ht = "horizontal_treatment", vt = "vertical_treatment"),
                      swap_within = list(ht = "block", vt = "block"))

```

### Output of the Optimisation

```{r strip-plot-output}
strip_result
```

### Visualise the Output

```{r strip-plot-plot2}
autoplot(strip_result, treatments = "horizontal_treatment") + ggplot2::labs(title = "Tillage Treatments")
autoplot(strip_result, treatments = "vertical_treatment") + ggplot2::labs(title = "Planting Date Treatments")
```

An optimised strip-plot design with well-arranged treatment combinations!

# Incomplete Block Designs

## Overview

When the number of treatments is large, complete blocks may be impractical due to field size or resource constraints. Incomplete block designs use smaller blocks where not all treatments appear in each block, while still maintaining good statistical properties.

## Types of Incomplete Block Designs

### Balanced Incomplete Block Design (BIBD)

The most restrictive but statistically optimal incomplete block design.

#### Characteristics:

- Each treatment appears in exactly $r$ blocks
- Each block contains exactly $k$ treatments
- Each pair of treatments appears together in exactly $λ$ blocks
- Perfect balance but limited parameter combinations

#### Parameters:

- $v$ = number of treatments
- $b$ = number of blocks  
- $r$ = number of blocks containing each treatment
- $k$ = number of treatments per block
- $λ$ = number of blocks containing each pair of treatments
- $bk = vr$ and $λ(v-1) = r(k-1)$

What may become apparent from the characteristics and parameters listed above is that these designs are not trivial, and [there are specific and limited combinations that will work](https://en.wikipedia.org/wiki/Block_design#Pairwise_balanced_uniform_designs_(2-designs_or_BIBDs)). In the case of speed, a custom objective function is required to ensure that each pair of treatments appear the same number of times. For an example and further discussion, see the [vignette on custom objective functions](custom_objective_functions.html).


### Resolvable Incomplete Block Design (RIBD)

More flexible incomplete block designs where blocks can be grouped into complete replications.

#### Characteristics:

- Blocks can be organised into complete replications
- Each replication contains every treatment exactly once
- More flexible parameter combinations than BIBD
- Excellent for multi-location trials

### Partially Balanced Incomplete Block Design (PBIBD)

Relaxes the balance requirements of BIBD while maintaining good statistical properties.

## When to Use Incomplete Block Designs

- **Large number of treatments** (typically >15-20)
- **Limited block size** due to field homogeneity constraints
- **Multi-location variety trials** where shipping costs limit replication
- **Resource limitations** preventing complete replication
- **Preliminary screening** of large treatment sets

## Example: Resolvable Incomplete Block Design for 6 Varieties

Consider a trial with 15 treatments where complete blocks would be too large for field homogeneity. We'll use an incomplete block design with blocks of size 5.

## Setting Up a Resolvable Incomplete Block Design with speed

Firstly we need to create a data frame representing the incomplete block design. Here we will use a systematic approach to generate the blocks and treatment combinations.

```{r ribd-df}
# Create the data frame
ribd_df <- data.frame(
  row = rep(1:3, 6),                             # Row within each block
  col = rep(1:6, each = 3),                      # Column corresponds to block
  replicate = rep(1:3, each = 6),                # 3 replicates, 6 observations each
  block = rep(1:6, each = 3),                    # 6 blocks total, 3 treatments per block
  treatment = paste0("V", rep(1:6, times = 3))   # Treatment assignments
)

# View the design
head(ribd_df)
```

```{r}
#| echo: false
#| label: fig-ribdplot1
#| fig-cap: "Initial layout of the resolvable incomplete block design showing systematic treatment distribution."
class(ribd_df) <- c("design", class(ribd_df))
p1 <- autoplot(ribd_df, treatments = "replicate") + ggplot2::labs(title = "Replicate layout")
p2 <- autoplot(ribd_df, treatments = "block") + ggplot2::labs(title = "Block layout")
p3 <- autoplot(ribd_df) + ggplot2::labs(title = "Initial treatment layouts")
p1 + p2 + p3 +
  plot_layout(ncol = 2) +
  plot_annotation(title = "Initial Systematic Resolvable Incomplete Block Design")
```

@fig-ribdplot1 shows the systematic resolvable incomplete block layout before optimisation. Note that replicates are made of two blocks, in each of which half the treatments will appear, and replicates are made up of pairs of blocks. The treatments can be swapped between blocks, but need to remain within their replicate.

### Performing the Optimisation

```{r ribd-example}
ribd_result <- speed(ribd_df, 
                     swap = "treatment", 
                     swap_within = "replicate", 
                     seed = 42)    
```

### Output of the Optimisation

```{r ribd-output}
ribd_result
str(ribd_result)
```

### Visualise the Output

```{r ribd-plot4}
autoplot(ribd_result)
```

We see that each block by itself only contains half the treatments, but when combined, the pairs have a full replicate. The algorithm has also spatially optimised the treatments across rows and columns, giving a nicely optimised resolvable incomplete block design.

# P-Rep (Partially Replicated) Designs

## Overview

P-rep designs are a modern approach to plant breeding trials where a subset of entries (typically checks and selected test lines) are replicated while the majority of test entries appear only once. This provides a balance between statistical power and resource efficiency.

## Structure

- **Replicated entries**: Key checks and promising lines (typically 20-25% of entries)
- **Unreplicated entries**: Majority of test lines (75-80% of entries)
- **Strategic replication**: Based on breeding program priorities
- **Spatial distribution**: Replicates spread throughout the trial

## Key Features

### Flexible Replication

- **Variable replication levels** based on entry importance
- **Adaptive strategies** for different breeding stages
- **Resource-efficient** compared to full replication

### Modern Analysis Methods

- **Mixed models** with spatial correlation
- **BLUP prediction** for unreplicated entries
- **Genomic information** integration possible
- **Spatial adjustment** for field variation

## When to Use P-Rep Designs

- **Large-scale breeding trials** (>500 entries)
- **Early generation testing** with limited seed
- **Resource-constrained** breeding programs
- **High-throughput phenotyping** applications
- **When full replication is impractical**

## Example: P-Rep Design for Large Breeding Trial

Consider a breeding trial with 140 entries where 40 key entries (checks and promising lines) are replicated twice while others appear once. This is a single site design with two blocks.

## Setting Up P-Rep Designs with speed

```{r prep-design-df}
prep_design <- data.frame(
  row = rep(1:14, each = 10), 
  col = rep(1:10, times = 14), 
  block = rep(rep(1:2, each = 5), 14),
  entry = c(paste0("V", rep(1:40, 2)), paste0("V", 41:100)) # 100 varieties, 40 duplicated
)

# Create an indicator for the duplicated entries
prep_design$duplicated <- duplicated(prep_design$entry) | duplicated(prep_design$entry, fromLast = TRUE)

head(prep_design)
```

```{r}
#| echo: false
#| label: fig-prepplot1
#| fig-cap: "Initial layout of the p-rep design showing systematic treatment distribution."
class(prep_design) <- c("design", class(prep_design))
autoplot(prep_design, treatments = "entry")
autoplot(prep_design, treatments = "duplicated")
```

This shows the initial p-rep design with duplicated entries distributed systematically. Once we have set up the data frame, the `speed()` optimisation call is quite straight-forward. Note that we have added `block` into the `spatial_factors` argument, to attempt to balance the replicated treatments between blocks as well. Typically with larger designs, we may also want to increase the number of `iterations` and `early_stop_iterations` to allow more swapping to take place, however in this case it is not necessary due to the low replication.

### Performing the Optimisation

```{r prep-design-example}
prep_result <- speed(prep_design,
                     swap = "entry",
                     spatial_factors = ~ block + row + col, 
                     seed = 42)
```

### Output of the Optimisation

```{r prep-design-output}
prep_result
str(prep_result)
```

Ideally here we would also like to see an even distribution of the duplicated entries between each block.

```{r prep-check-spread}
prep_result$design_df$duplicated <- duplicated(prep_result$design_df$entry) | duplicated(prep_result$design_df$entry, fromLast = TRUE)

sum(prep_result$design_df$duplicated[prep_result$design_df$block==1])
any(duplicated(prep_result$design_df$entry[prep_result$design_df$block==1]))
```

With 40 duplicated varieties in this block, we know we also have 40 in the other block.

### Visualise the Output

```{r prep-design-plot2}
autoplot(prep_result, treatments = "entry")
```

An optimised p-rep design with strategic replication and spatial distribution. Note that because the treatments column is not called "treatment", we need to specify the `treatments` argument in the `autoplot()` function.

# Row-Column Designs with Blocking

## Overview

Advanced row-column designs incorporate additional blocking structures to control for multiple sources of variation simultaneously. These designs are particularly useful for large, complex experiments where variation occurs in multiple dimensions.

## Types of Row-Column Blocking

### Row-Column Designs with Superblocks

- **Superblocks** contain multiple row-column units
- **Hierarchical structure** with blocks within blocks
- **Multi-level variation control**
- **Suitable for very large experiments**

### Resolvable Row-Column Designs

- **Complete replications** within the row-column structure
- **Replications as additional blocking factor**
- **Multiple complete layouts**
- **Good for multi-location or multi-season trials**

### Nested Row-Column Designs

- **Plots nested within row-column intersections**
- **Sub-sampling within main experimental units**
- **Multiple measurements per treatment combination**
- **Increased precision for specific comparisons**

## Applications

- **Multi-location breeding trials** with spatial control
- **Large greenhouse experiments** with multiple environmental gradients
- **Field trials with complex spatial patterns**
- **High-throughput phenotyping** platforms

## Example: Row-Column Design with Blocking in Two Dimensions

Consider a large field trial with 40 varieties each replicated 10 times, requiring both row blocks and column blocks.

## Setting Up Row-Column Designs with Blocking

```{r rowcol-block-design-df}
blocking_2d_design <- data.frame(row = rep(1:20, each = 20), 
                                 col = rep(1:20, 20), 
                                 treatment = rep(paste("V", 1:40, sep = ""), 10), 
                                 rowBlock = rep(1:10, each = 40),
                                 colBlock = rep(rep(1:10, each = 2), 20))
head(blocking_2d_design)
```

```{r}
#| echo: false
#| label: fig-2dblockplot1
#| fig-cap: "Initial layout of the 2D blocking design showing systematic treatment distribution."
class(blocking_2d_design) <- c("design", class(blocking_2d_design))
autoplot(blocking_2d_design, block = "rowBlock")
```

```{r}
#| echo: false
#| label: fig-2dblockplot2
#| fig-cap: "2D blocking design showing rowBlock layout."
autoplot(blocking_2d_design, block = "rowBlock", treatments = "rowBlock")
```

```{r}
#| echo: false
#| label: fig-2dblockplot3
#| fig-cap: "2D blocking design showing colBlock layout."
autoplot(blocking_2d_design, block = "colBlock", treatments = "colBlock")
```

This shows the initial row-column design with hierarchical blocking structure.

### Performing the Optimisation

Now we will use the `speed()` function to optimise this design. We will swap treatments within row blocks, while also considering column blocks as a spatial factor. Note that we also set some optimisation parameters to allow for more swaps, as this is a larger design with more treatments.

```{r rowcol-block-design-example}
#| cache: true
options(speed.swap_count = 5, speed.swap_all_blocks = TRUE, speed.adaptive_swaps = TRUE)

blocking_2d_result <- speed(blocking_2d_design, 
                            swap = "treatment", 
                            swap_within = "rowBlock",
                            spatial_factors = ~ colBlock, 
                            iterations = 150000,
                            early_stop_iterations = 50000, 
                            seed = 42, quiet = TRUE)
```

### Output of the Optimisation

```{r rowcol-block-design-output}
blocking_2d_result
```

### Visualise the Output

```{r}
#| label: fig-2dblockplot4
#| fig-cap: "Final layout of the 2D blocking design showing optimised treatment distribution."
#| echo: false
autoplot(blocking_2d_result, block = "rowBlock")
```

An optimised row-column design with blocking in two directions.

<!---
# Designs for Irregular Areas

## Overview

Real-world experimental sites often have irregular shapes, obstacles, or varying conditions that prevent the use of standard rectangular designs. Specialised approaches are needed to maintain statistical validity while accommodating practical constraints.

## Types of Irregular Situations

### Irregular Field Shapes

- **Non-rectangular fields** (triangular, circular, L-shaped)
- **Curved boundaries** following natural features
- **Multiple disconnected areas**
- **Terraced or sloped fields**

### Field Obstacles

- **Trees, buildings, or equipment** within the field
- **Wet areas or rocky patches**
- **Access roads or pathways**
- **Utility lines or structures**

### Varying Field Conditions

- **Distinct soil types** within the field
- **Drainage patterns** creating sones
- **Shade gradients** from adjacent features
- **Historical management differences**

## Design Strategies for Irregular Areas

### Adaptive Blocking

- **Blocks follow field contours** or natural boundaries
- **Variable block sizes** to accommodate constraints
- **Flexible shapes** rather than rectangular blocks
- **Natural groupings** of homogeneous areas

### Constraint-Based Optimisation

- **Spatial constraints** for inaccessible areas
- **Adjacency rules** modified for irregular layouts
- **Distance-based optimisation** rather than grid-based
- **Weighted optimisation** for varying quality areas

### Incomplete Coverage Designs

- **Strategic plot placement** in available areas
- **Systematic gaps** where obstacles occur
- **Interpolation methods** for spatial analysis
- **Robust analysis approaches**

## Example: Irregular Field Design with Obstacles

Consider a field trial that must work around existing trees, buildings, and drainage areas, requiring adaptive plot placement.

## Setting Up Designs for Irregular Areas

```{r irregular-design-df}
# Placeholder: Initialise irregular field design
# # Define field boundaries and obstacles
# field_constraints <- list(
#   boundaries = data.frame(x = c(0, 50, 50, 0), y = c(0, 0, 30, 30)),
#   obstacles = data.frame(x = c(15, 35), y = c(10, 20), radius = c(3, 2))
# )
# irregular_design <- initialise_design_df(entries = 48, reps = 3,
#                                        constraints = field_constraints)
# head(irregular_design)
```

```{r irregular-design-plot1}
#| echo: false
# Placeholder: Initial visualisation with constraints
# class(irregular_design) <- c("design", class(irregular_design))
# autoplot(irregular_design) + 
#   # Add constraint visualisation
#   geom_polygon(data = field_constraints$obstacles, 
#                aes(x = x, y = y), alpha = 0.3, fill = "red")
```

This shows the initial design layout accommodating field constraints and obstacles.

### Performing the Optimisation

```{r irregular-design-example}
# Placeholder: Optimise design with spatial constraints
# irregular_result <- speed(irregular_design,
#                          swap = "entry",
#                          constraints = field_constraints,
#                          seed = 42)
# irregular_result
```

### Output of the Optimisation

```{r irregular-design-output}
# Placeholder: Show structure of results
# str(irregular_result)
```

### Visualise the Output

```{r irregular-design-plot2}
# Placeholder: Final visualisation with constraints
# autoplot(irregular_result) + 
#   # Add constraint visualisation
#   geom_polygon(data = field_constraints$obstacles, 
#                aes(x = x, y = y), alpha = 0.3, fill = "red")
```

An optimised design that efficiently uses available space while respecting field constraints!
--->
<!---
# Factorial Designs in Incomplete Blocks

## Overview

When factorial experiments involve many treatment combinations, complete replication may be impractical. Factorial designs can be embedded within incomplete block structures to maintain efficiency while reducing experimental size.

## Approaches

### Confounded Factorial Designs

- **Confound** high-order interactions with blocks
- **Sacrifice** information on some interactions
- **Maintain** efficiency for main effects and important interactions

### Fractional Factorial in Blocks

- Use **fractional factorial** structure
- **Block** the reduced treatment set
- **Alias** some effects but maintain key comparisons

## Applications

- **Multi-factor agricultural trials** with resource constraints
- **Industrial experiments** with expensive experimental units
- **Screening experiments** for multiple factors

## Setting Up Factorial Designs in Incomplete Blocks with speed

```{r factorial-incomplete-example, eval=FALSE}
# Placeholder for Factorial in Incomplete Blocks example
# This will show:
# - Designing confounded factorial experiments
# - Choosing appropriate confounding schemes
# - Optimising block arrangements with speed
# - Handling fractional factorials in blocks
# - Analysis implications of confounding
# - Efficiency comparisons with complete designs
```

# Nested and Hierarchical Designs

## Overview

Nested designs involve factors that are nested within levels of other factors, creating hierarchical structures. These are common in multi-location trials and breeding programs.

## Structure

### Simple Nesting

- Factor B nested within Factor A
- Different levels of B for each level of A
- Example: Varieties within breeding programs

### Multiple Nesting

- Several factors nested within higher-level factors
- Complex hierarchical relationships
- Example: Plots within blocks within locations

## Applications

- **Multi-location variety trials**
- **Breeding program comparisons**  
- **Management system studies**
- **Genotype × environment interactions**

## Setting Up Nested Designs with speed

```{r nested-design-example, eval=FALSE}
# Placeholder for Nested Design example
# This will show:
# - Creating hierarchical factor structures
# - Optimising arrangements within nested constraints
# - Handling multiple levels of nesting
# - Spatial optimisation across hierarchy levels
# - Analysis considerations for nested factors
# - Visualisation of hierarchical structure
```

# Design Selection Guidelines for Complex Designs

## Decision Framework

### Treatment Numbers

- **< 20 treatments**: Consider RCBD or Latin Square
- **20-100 treatments**: Alpha designs often optimal  
- **> 100 treatments**: Augmented or incomplete block designs
- **Multiple factors**: Factorial arrangements in blocks

### Resource Constraints

- **Limited field area**: Incomplete blocks or augmented designs
- **High treatment costs**: Augmented designs with fewer checks
- **Labour limitations**: Simpler designs with fewer blocks

### Precision Requirements

- **High precision needed**: Complete designs or highly replicated checks
- **Screening phase**: Augmented designs acceptable
- **Final testing**: Complete replication recommended

## Efficiency Considerations

### Statistical Efficiency

- Compare **A-efficiency**, **D-efficiency**, and **E-efficiency**
- Consider **relative efficiency** to RCBD
- Balance **precision** vs **resource use**

### Practical Efficiency

- **Field layout** feasibility
- **Management** complexity
- **Analysis** requirements
- **Implementation** costs

# Advanced Spatial Optimisation with speed

## Optimisation Strategies for Complex Designs

### Multi-level Optimisation

- **Hierarchical optimisation** for nested structures
- **Constraint handling** for complex design rules
- **Multi-objective** optimisation balancing competing goals

### Custom Objective Functions

- **Weighted combinations** of different criteria
- **Penalty functions** for constraint violations
- **Domain-specific** optimisation goals

## Computational Considerations

### Large Design Challenges

- **Memory management** for large treatment sets
- **Convergence** monitoring and criteria
- **Parallel processing** options
- **Progress tracking** for long optimisations

### Quality Assessment

- **Convergence diagnostics**
- **Multiple optimisation runs**
- **Sensitivity analysis**
- **Robustness testing**

# Best Practices for Complex Designs

## Design Phase

1. **Clearly define objectives** and constraints
2. **Consider practical limitations** early
3. **Compare multiple design options** systematically  
4. **Validate design properties** before implementation
5. **Plan for analysis** requirements

## Implementation Phase

1. **Detailed field maps** and plot identification
2. **Quality control** procedures for layout
3. **Backup plans** for implementation issues
4. **Documentation** of actual vs planned layout
5. **Training** for field personnel

## Analysis Phase

1. **Appropriate statistical models** for design structure
2. **Spatial analysis** consideration
3. **Model validation** and diagnostics
4. **Effect interpretation** in context of design
5. **Reporting** design details and limitations
--->

# Conclusion

Complex experimental designs offer powerful solutions for challenging agricultural research scenarios. The `speed` package provides essential tools for optimising these designs spatially, ensuring that the statistical advantages of sophisticated designs are fully realised in practice.

Key benefits of using complex designs with spatial optimisation include:

- **Efficient resource utilisation** for large-scale studies
- **Maintained statistical rigor** despite practical constraints  
- **Enhanced precision** through appropriate blocking and spatial arrangement
- **Flexible solutions** for diverse research objectives
- **Practical feasibility** through optimised field layouts

When selecting and implementing complex designs, researchers should carefully balance statistical efficiency, practical constraints, and research objectives. The spatial optimisation capabilities of `speed` ensure that these sophisticated designs achieve their full potential in real-world applications.

<!-- For guidance on comparing the efficiency of different design options, see the **"Comparing Experimental Design Efficiency with speed"** vignette. -->

## Further Reading

### Specialised Design References

- Cochran, W.G. & Cox, G.M. (1957). *Experimental Designs*
- John, J.A. & Williams, E.R. (1995). *Cyclic and Computer Generated Designs*  
- Bailey, R.A. (2008). *Design of Comparative Experiments*
- Patterson, H.D. & Williams, E.R. (1976). "A new class of resolvable incomplete block designs"

### Agricultural Applications

- Kempton, R.A. & Fox, P.N. (1997). *Statistical Methods for Plant Variety Evaluation*
- Singh, R. & Chaudhary, B.D. (1985). *Biometrical Methods in Quantitative Genetic Analysis*

## Related Vignettes

- [Common Agricultural Experimental Designs with speed](speed.html) - Foundational designs for most agricultural applications
<!-- - **"Comparing Experimental Design Efficiency with speed"** - Tools for evaluating and comparing design efficiency -->

---

*This vignette demonstrates advanced applications of the `speed` package for complex experimental designs. For foundational designs, see the "[Common Agricultural Experimental Designs](speed.html)" vignette. For specific implementation details, consult the package documentation and function help files.*
